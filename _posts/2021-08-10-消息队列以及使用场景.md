# 消息队列以及使用场景

在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6 "计算机科学")中，**消息队列**（英语：Message queue）是一种[进程间通信](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1 "进程间通信")或同一进程的不同[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B "线程")间的通信方式，[软件](https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94 "软件")的[贮列](https://zh.wikipedia.org/wiki/%E8%B2%AF%E5%88%97 "贮列")用来处理一系列的[输入](https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5 "输入")，通常是来自用户。消息队列提供了[异步](https://zh.wikipedia.org/wiki/%E7%95%B0%E6%AD%A5 "异步")的[通信协议](https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE "通信协议")，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在[队列](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97 "队列")中，直到接收者取回它。

简单的说，就是一个中间件，可以存储生产者产生的数据，可以被消费者进行消费，而生产者和消费者之间处于解耦。对于不同的消息队列实现来说，例如 Kafka、rabbitMQ 等等，会有一些功能上或细节上的差距，但本质还是做上下文组件的数据传递。

## 好处

- 解耦：在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
- 提速/缓冲：在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列的加入可以视为一种缓存。
- 异步通信：消息队列结构上就决定了异步通信。
- 削峰：消息队列能够使关键组件顶住突发的访问压力。

## 缺点

- 引入复杂度：毕竟多了一个中间组件，原始的数据交互模式变得更复杂
- 暂时的不一致性：有了中间状态，上下游之间存在不一致性，对于上游来说，存入数据队列就等于下游已经读取，但实际上这时有个时间差的

## 什么情况下可以使用消息队列

- 生产者不需要从消费者处获得反馈
- 容许短暂的不一致性
- 可以带来系统性能上的提升

## 常用 MQ 的对比

### RabbitMQ

RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。

### Redis

Redis 是一个基于 Key-Value 对的 NoSQL 数据库，开发维护很活跃。虽然它是一个 Key-Value 数据库存储系统，但它本身支持 MQ 功能，所以完全可以当做一个轻量级的队列服务来使用。对于 RabbitMQ 和 Redis 的入队和出队操作，各执行 100 万次，每 10 万次记录一次执行时间。测试数据分为 128Bytes、512Bytes、1K 和 10K 四个不同大小的数据。实验表明：入队时，当数据比较小时 Redis 的性能要高于 RabbitMQ，而如果数据大小超过了 10K，Redis 则慢的无法忍受；出队时，无论数据大小，Redis 都表现出非常好的性能，而 RabbitMQ 的出队性能则远低于 Redis。

### ZeroMQ

ZeroMQ 号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ 能够实现 RabbitMQ 不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这 MQ 能够应用成功的挑战。ZeroMQ 具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用 ZeroMQ 程序库，可以使用 NuGet 安装，然后你就可以愉快的在应用程序之间发送消息了。但是 ZeroMQ 仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter 的 Storm 0.9.0 以前的版本中默认使用 ZeroMQ 作为数据流的传输（Storm 从 0.9 版本开始同时支持 ZeroMQ 和 Netty 作为传输模块）。

### ActiveMQ

ActiveMQ 是 Apache 下的一个子项目。 类似于 ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于 RabbitMQ，它少量代码就可以高效地实现高级应用场景。

### Kafka/Jafka

Kafka 是 Apache 下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而 Jafka 是在 Kafka 之上孵化而来的，即 Kafka 的一个升级版。具有以下特性：快速持久化，可以在 O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到 10W/s 的吞吐速率；完全的分布式系统，Broker、Producer、Consumer 都原生自动支持分布式，自动实现负载均衡；支持 Hadoop 数据并行加载，对于像 Hadoop 的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka 通过 Hadoop 的并行加载机制统一了在线和离线的消息处理。Apache Kafka 相对于 ActiveMQ 是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。

## 参考

- [消息队列](https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
- [什么是消息队列？](https://aws.amazon.com/cn/message-queue/)
- [Kafka 学习之路 （一）Kafka 的简介](https://www.cnblogs.com/qingyunzong/p/9004509.html)
- [消息队列的使用场景是怎样的？](https://www.zhihu.com/question/34243607)
