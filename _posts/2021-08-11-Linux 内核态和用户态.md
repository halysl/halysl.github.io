# Linux 内核态和用户态
先解释下这两者到底是什么区别。

假设程序需要从磁盘读取数据，数据并不是从磁盘直接加载到程序所持有的内存中，而是：

- 先将数据从磁盘复制到`内核 Buffer`
- 再将数据从`内核 Buffer` 复制到`用户 Buffer`

我们来分析下上面两步：

- 数据从磁盘（硬件）复制到`内核 Buffer`（内核内存），这是一次 IO 过程
- 数据从`内核 Buffer` 复制到`用户 Buffer`（用户内存）

所以：内核态和用户态本质上只是持有资源的不同，内核态下的指令可以访问到所有资源，而用户态下的指令只能访问到特定资源（CPU、内存）。

用户态、内核态的指令都是 CPU 都在执行，所以我们可以换个说法，实际上这个态代表的是**当前 CPU 的状态**。那既然这些指令最终都由 CPU 执行，那对其区分的理由是什么呢？

那是因为，CPU 指令根据其重要的程度，也分为不同的权限。有一些指令执行失败了无关痛痒，而有一些指令失败了会导致整个操作系统崩溃，甚至需要重启系统。如果将这些指令**随意**开放给应用程序的话，整个系统崩溃的概率将会大大的增加。

![Intel x86 架构下的权限.jpg](http://121.5.131.212:8810/images/2022/03/24/606beaa3f047f88e6963349044f075d1.jpg)

在 Linux 系统中，由于只有 Ring0 和 Ring3 级别的指令，所以我们可以对用户态、内核态给一个**更细节的区别描述**：运行 Ring0 级别指令的叫**内核态**，运行 Ring3 级别指令的叫**用户态**。

了解了指令集权限的概念，我们就可以再更正一下上面的描述：什么**态**实际上代表的是**当前 CPU 正在执行什么级别的指令**

高情商

-   ring 0被叫做内核态，完全在操作系统内核中运行
-   ring 3被叫做用户态，在应用程序中运行

低情商

-   执行内核空间的代码，具有ring 0保护级别，有对硬件的所有操作权限，可以执行所有`C P U 指令集`，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机
-   在用户模式下，具有ring 3保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的

## 用户态与内核态

用户态与内核态的概念就是 CPU 指令集权限的区别，进程中要读写 `IO`，必然会用到 ring 0 级别的 `CPU 指令集`，而此时 CPU 的指令集操作权限只有 ring 3，为了可以操作ring 0 级别的 `CPU 指令集`， CPU 切换指令集操作权限级别为 ring 0，CPU 再执行相应的 ring 0 级别的 `CPU 指令集`（内核代码），执行的内核代码会使用当前进程的内核栈。

PS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用

## 用户态与内核态的空间

在内存资源上的使用，操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」，以Linux32位操作系统为例，它的寻址空间范围是 `4G`（2的32次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 `1G`（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 `3G`（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。
  
-   用户态：只能操作 `0-3G` 范围的低位虚拟空间地址
-   内核态：`0-4G` 范围的虚拟空间地址都可以操作，尤其是对 `3-4G` 范围的高位虚拟空间地址必须由内核态去操作
-   补充：`3G-4G` 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据

每个进程的 `4G` 虚拟空间地址，高位 `1G` 都是一样的，即内核空间。只有剩余的 `3G` 才归进程自己使用，换句话说就是， 高位 `1G` 的内核空间是被所有进程共享的！

最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用。

## 切换
-   系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork() 就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断，也可以称为软中断
-   异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
-   中断：当 CPU 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。

![Linux两种状态.jpg](http://121.5.131.212:8810/images/2022/03/24/a195c59066778b611992a5adee102e8a.jpg)


## 参考

- [用户态和内核态的区别是啥](https://zhuanlan.zhihu.com/p/447488276)
- [从根上理解用户态与内核态](https://zhuanlan.zhihu.com/p/388057431)
